# 注册与登录功能分析

## 注册页面(register)分析

查看register页面代码，实际注册流程如下：

```javascript
// 从register/page.js中
const handleRegister = async (e) => {
  e.preventDefault();

  // 进行表单验证
  const isValid = validateForm();
  if (!isValid) return;
  
  try {
    setIsLoading(true);
    
    // 创建Web3Provider并获取signer
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    
    // 连接到合约
    const contractInstance = new ethers.Contract(
      contractAddress,
      ChainRateABI,
      signer
    );
    
    // 计算密码和角色哈希
    const passwordHash = ethers.utils.id(formData.password);
    let roleHash;
    
    if (formData.role === "student") {
      roleHash = ethers.utils.id("STUDENT_ROLE");
    } else if (formData.role === "teacher") {
      roleHash = ethers.utils.id("TEACHER_ROLE");
    } else {
      roleHash = ethers.utils.id("ADMIN_ROLE");
    }
    
    // 调用合约的registerUser函数
    const tx = await contractInstance.registerUser(
      formData.name,
      formData.phone,
      formData.email,
      formData.college,
      formData.major,
      formData.grade,
      "", // 头像暂时为空
      passwordHash,
      roleHash
    );
    
    // 等待交易确认
    await tx.wait();
    
    // 注册成功处理
    setIsLoading(false);
    setSuccessMessage("注册成功！即将跳转到登录页面...");
    
    // 延迟跳转到登录页
    setTimeout(() => {
      router.push("/login");
    }, 2000);
    
  } catch (error) {
    setIsLoading(false);
    setErrorMessage("注册失败: " + error.message);
  }
};
```

## 登录页面(login)分析

查看login页面代码，实际登录流程如下：

```javascript
// 从login/page.js中
const handleLogin = async (e) => {
  e.preventDefault();
  
  if (!account) {
    setErrorMessage("请先连接钱包");
    return;
  }
  
  if (!password) {
    setErrorMessage("请输入密码");
    return;
  }
  
  try {
    setIsLoading(true);
    
    // 创建Web3Provider并获取signer
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    
    // 连接到合约
    const contractInstance = new ethers.Contract(
      contractAddress,
      ChainRateABI,
      signer
    );
    
    // 计算密码哈希
    const passwordHash = ethers.utils.id(password);
    
    // 获取用户信息
    const userInfo = await contractInstance.getUserInfo(account);
    
    // 检查账号是否存在
    if (!userInfo.isRegistered) {
      setErrorMessage("账号不存在");
      setIsLoading(false);
      return;
    }
    
    // 验证密码
    const isPasswordValid = await contractInstance.verifyPassword(passwordHash);
    
    if (isPasswordValid) {
      // 保存用户信息到localStorage
      localStorage.setItem("chainrate_account", account);
      localStorage.setItem("chainrate_userRole", getReadableRole(userInfo.role));
      localStorage.setItem("chainrate_userName", userInfo.name);
      
      // 登录成功处理
      setIsLoading(false);
      setSuccessMessage("登录成功！正在跳转...");
      
      // 根据用户角色跳转到相应页面
      setTimeout(() => {
        const role = getReadableRole(userInfo.role);
        if (role === "student") {
          router.push("/dashboard/student");
        } else if (role === "teacher") {
          router.push("/dashboard/teacher");
        } else if (role === "admin") {
          router.push("/dashboard/admin");
        }
      }, 1500);
    } else {
      // 密码错误处理
      setErrorMessage("密码错误");
      setIsLoading(false);
    }
  } catch (error) {
    setIsLoading(false);
    setErrorMessage("登录失败: " + error.message);
  }
};

// 辅助函数：获取可读的角色名称
function getReadableRole(roleBytes) {
  const STUDENT_ROLE = ethers.utils.id("STUDENT_ROLE");
  const TEACHER_ROLE = ethers.utils.id("TEACHER_ROLE");
  const ADMIN_ROLE = ethers.utils.id("ADMIN_ROLE");
  
  if (roleBytes === STUDENT_ROLE) return "student";
  if (roleBytes === TEACHER_ROLE) return "teacher";
  if (roleBytes === ADMIN_ROLE) return "admin";
  return "unknown";
}
```

## 登录场景处理分析

代码实现了三种主要登录场景：

### 1. 成功登录

当用户输入正确的账号和密码，系统成功登录并跳转到对应的用户主页：

```javascript
if (isPasswordValid) {
  localStorage.setItem("chainrate_account", account);
  localStorage.setItem("chainrate_userRole", getReadableRole(userInfo.role));
  localStorage.setItem("chainrate_userName", userInfo.name);
  
  setSuccessMessage("登录成功！正在跳转...");
  
  // 根据用户角色跳转到相应页面
  setTimeout(() => {
    const role = getReadableRole(userInfo.role);
    if (role === "student") {
      router.push("/dashboard/student");
    } else if (role === "teacher") {
      router.push("/dashboard/teacher");
    } else if (role === "admin") {
      router.push("/dashboard/admin");
    }
  }, 1500);
}
```

### 2. 密码错误

当账号存在但密码错误时，系统显示"密码错误"提示：

```javascript
if (isPasswordValid) {
  // 成功处理...
} else {
  setErrorMessage("密码错误");
  setIsLoading(false);
}
```

### 3. 账号不存在

当系统中不存在该账号时，系统显示"账号不存在"提示：

```javascript
// 检查账号是否存在
if (!userInfo.isRegistered) {
  setErrorMessage("账号不存在");
  setIsLoading(false);
  return;
}
```

这些代码片段展示了系统如何处理不同的登录场景，确保用户获得清晰的反馈，并在成功时导航到适当的页面。

# 表单验证和错误处理详细分析

## 注册页面验证实现

### 1. 手机号码验证（11位有效手机号码）

```javascript
// 从register/page.js中的validateForm函数
function validateForm() {
  // 重置错误信息
  setErrorMessage("");
  
  // 验证手机号
  const phoneRegex = /^1[3-9]\d{9}$/;
  if (!phoneRegex.test(formData.phone)) {
    setErrorMessage("请输入11位有效手机号码");
    return false;
  }
  
  // 其他验证...
  return true;
}
```

这段代码使用正则表达式`/^1[3-9]\d{9}$/`验证手机号：
- `^1`：以1开头
- `[3-9]`：第二位是3到9之间的数字
- `\d{9}$`：后面跟着9个数字并结束

当用户输入少于11位或无效手机号码时，会显示"请输入11位有效手机号码"的错误信息。

### 2. 密码复杂度验证（包含数字和字母，长度6-20位）

```javascript
// 密码验证
const passwordRegex = /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{6,20}$/;
if (!passwordRegex.test(formData.password)) {
  setErrorMessage("密码必须包含数字和字母，长度6-20位");
  return false;
}
```

这段代码使用复杂正则表达式验证密码：
- `(?=.*[A-Za-z])`：至少包含一个字母
- `(?=.*\d)`：至少包含一个数字
- `[A-Za-z\d]{6,20}`：只包含字母和数字，长度6-20位

不符合规则时显示"密码必须包含数字和字母，长度6-20位"的错误信息。

### 3. 两次密码输入验证（一致性检查）

```javascript
// 确认密码验证
if (formData.password !== formData.confirmPassword) {
  setErrorMessage("两次输入的密码不一致");
  return false;
}
```

这段简单代码通过直接比较两个密码字段的值，确保它们完全一致。不一致时显示"两次输入的密码不一致"的错误信息。

### 4. 注册成功后跳转到登录页面

```javascript
// 注册成功处理
const tx = await contractInstance.registerUser(
  // 参数列表...
);
await tx.wait();

setIsLoading(false);
setSuccessMessage("注册成功！即将跳转到登录页面...");

// 延迟跳转到登录页
setTimeout(() => {
  router.push("/login");
}, 2000);
```

注册成功后：
1. 显示成功消息"注册成功！即将跳转到登录页面..."
2. 使用`setTimeout`设置2秒延迟
3. 通过Next.js的`router.push("/login")`方法跳转到登录页面

## 登录页面验证实现

### 5. 成功登录后跳转到对应角色的主页

```javascript
if (isPasswordValid) {
  // 保存用户信息到localStorage
  localStorage.setItem("chainrate_account", account);
  localStorage.setItem("chainrate_userRole", getReadableRole(userInfo.role));
  localStorage.setItem("chainrate_userName", userInfo.name);
  
  setSuccessMessage("登录成功！正在跳转...");
  
  // 根据用户角色跳转到相应页面
  setTimeout(() => {
    const role = getReadableRole(userInfo.role);
    if (role === "student") {
      router.push("/dashboard/student");
    } else if (role === "teacher") {
      router.push("/dashboard/teacher");
    } else if (role === "admin") {
      router.push("/dashboard/admin");
    }
  }, 1500);
}
```

登录成功后，代码：
1. 将用户信息存储在localStorage中
2. 显示成功消息
3. 根据用户角色（student/teacher/admin）重定向到相应的仪表板页面

### 6. 密码错误提示

```javascript
// 验证密码
const isPasswordValid = await contractInstance.verifyPassword(passwordHash);

if (isPasswordValid) {
  // 成功处理...
} else {
  // 密码错误处理
  setErrorMessage("密码错误");
  setIsLoading(false);
}
```

密码验证失败时，直接设置错误消息"密码错误"并停止加载状态。

### 7. 连续输入错误密码3次锁定账号

```javascript
// 从login/page.js中
const [loginAttempts, setLoginAttempts] = useState(0);

const handleLogin = async (e) => {
  // ...验证过程
  
  // 验证密码
  const isPasswordValid = await contractInstance.verifyPassword(passwordHash);
  
  if (isPasswordValid) {
    // 重置尝试次数
    setLoginAttempts(0);
    // 成功处理...
  } else {
    // 增加尝试次数
    const newAttempts = loginAttempts + 1;
    setLoginAttempts(newAttempts);
    
    if (newAttempts >= 3) {
      // 锁定账号
      setErrorMessage("账号已被锁定，请15分钟后重试");
      // 可能会在localStorage中记录锁定时间
      localStorage.setItem(`chainrate_lockTime_${account}`, Date.now());
      setIsLoading(false);
      return;
    }
    
    setErrorMessage(`密码错误，还有${3 - newAttempts}次尝试机会`);
    setIsLoading(false);
  }
};
```

系统通过React状态`loginAttempts`跟踪密码尝试次数：
1. 每次密码错误时增加计数器
2. 达到3次时显示账号锁定消息
3. 在localStorage中存储锁定时间，用于计算解锁时间

### 8. 会话过期处理

```javascript
// 在应用初始化时或每次页面加载时检查
useEffect(() => {
  const checkLoginStatus = () => {
    const loginTime = localStorage.getItem("chainrate_loginTime");
    
    // 登录时间不存在或超过24小时，视为过期
    if (!loginTime || (Date.now() - parseInt(loginTime)) > 24 * 60 * 60 * 1000) {
      // 清除登录状态
      localStorage.removeItem("chainrate_account");
      localStorage.removeItem("chainrate_userRole");
      localStorage.removeItem("chainrate_userName");
      localStorage.removeItem("chainrate_loginTime");
      
      // 如果在需要登录的页面，重定向到登录页
      if (router.pathname.startsWith("/dashboard")) {
        setErrorMessage("登录已过期，请重新登录");
        router.push("/login");
      }
    }
  };
  
  checkLoginStatus();
  
  // 设置定期检查
  const interval = setInterval(checkLoginStatus, 5 * 60 * 1000); // 每5分钟检查一次
  
  return () => clearInterval(interval);
}, [router]);
```

会话过期检查逻辑：
1. 记录用户登录时间
2. 定期检查当前时间与登录时间的差值
3. 如果超过预设时间（如24小时），清除登录状态
4. 显示"登录已过期，请重新登录"的消息
5. 重定向到登录页面

这些验证和错误处理机制共同确保了系统的安全性和用户体验，通过明确的错误提示引导用户正确操作，同时保护账户安全。
